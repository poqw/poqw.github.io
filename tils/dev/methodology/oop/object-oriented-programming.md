# OOP(Object Oriented Programming)

[![](https://media.vlpt.us/images/ygh7687/post/5a98de44-834d-4980-876a-a736260d0bee/oop.png)](https://velog.io/@ygh7687/OOP%EC%9D%98-5%EC%9B%90%EC%B9%99%EA%B3%BC-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1)

## 객체지향의 오해들

객체지향의 세계에 대해 내가 했었던 오해들을 먼저 풀고 가면 좋을 것 같다. 왜냐하면 이건 내 블로그니까 내 맘이거든. 

### 중복된 코드들을 객체로 묶으면 객체지향이다?

나는 학부시절에 붕어빵과 붕어빵틀이 객체지향의 전부라고 이해했다. 어떤 로직이 중복된다면 그 로직을 클래스(붕어빵틀)로 몰아
인스턴스(붕어빵)를 만들고 메소드를 호출하여 재사용하곤 했다. 객체지향이 별 거 아닌 것만 같은 건방진 생각까지도 들었다.
그러나 프로젝트가 복잡해질수록 엉켜져버리는 의존성때문에 결국 중복을 허용하게 되었고, 얼마 지나지 않아 코드는 악취가 진동해
들여다 보기도 싫은 하수구 취급을 받게 되었다.

객체 지향적으로 프로그래밍을 한다는 말의 의미는, 프로그램이 객체들의 상호 협력에 의해서 운영되도록 한다는 것이다.
딱 한 가지 역할만을 담당하는 객체들이 모여서 자신이 하지 못하는 일들은 다른 객체에게 요청하고 또 다른 객체로부터 받은 요청에 부응하며
하나의 거대한 공동체를 이룬다.

학부 시절의 나 처럼 아무렇게나 막 짠다고 객체가 한 가지 역할만을 잘 담당하도록 자동으로 짜여지진 않는다.
지금와서는 객체는 붕어빵틀보다는, 어쩌면 공동체의 구성원인 사람에게 비유하는 게 더 어울리는 것 같다는 생각을 하고 있다.
우리는 옆 사람에게 내장과 근육조직에 대한 제어권을 넘기라고 하는 대신, 그냥 물을 떠달라고 말한다.
객체도 마찬가지다. **무엇을 하라고 시켜야지 그 속을 드러내보이라고 해선 안된다**, 또 내장이 외부로 흘러나오도록 두어서도 안된다.

객체는 최대한 한 가지 일만을 잘하는 전문가로 만들어 놓아야 한다. 그러려면 외부로 노출되는 인터페이스가 최대한 적어야 한다.
이를 위한 최선의 방법은 메시지를 결정하고, 그 메시지를 처리할 객체를 결정하는 것이다.
클래스를 만들고 그 안에다가 메소드를 만드는 걸로 시작하면 금방 여러가지 일을 하게 되는 혼종 객체가 탄생한다.

### 객체지향은 항상 옳다?

객체는 추상화를 통해 구현을 감추고, 절차지향적인 자료 구조는 있는 그대로를 드러낸다. 구현부를 감추기 위해 인터페이스를 도입하여
여러 객체들이 이 인터페이스를 구현하도록 했다고 하자. 인터페이스에 새로운 기능이 추가되는 경우 모든 객체를 수정해야 하는 난감한 상황에 빠진다.
하지만 이를 거의 구조체와 같은 자료 구조로 만들어 두고, 다른 클래스에서 `instanceof` 로 검사하여 어떠한 기능이 수행되도록 했다면
앞서와 같은 상황에서 모든 자료 구조는 수정으로부터 보호된다. 반면, 새로운 타입이 추가된는 경우에는 객체 지향이 더 좋다.
기존 객체들에 대한 수정을 하지 않아도 되자만, 절차지향에서는 기능을 수행하던 클래스의 모든 메소드가 수정되어야 한다.

따라서 우리는 새로운 자료 타입의 추가가 기대되는 경우 객체 지향으로, 새로운 함수의 추가가 기대되는 경우 절차 지향으로 구현하는 등
항상 객체지향이 올다는 미신은 버려야 한다. 단, 두 가지를 섞게 되면 단점만 모두 가져오는 꼴이므로 섞이지 않도록 주의해야 한다.

## 어떻게 객체지향적으로 프로그래밍 하는가

객체 지향적으로 프로그래밍하기 위해 SOLID를 지켜야 한다고 말한다.

### 추상화에 의존하라

런타임 의존성(객체)과 컴파일 타임 의존성(클래스)를 구분해서 컴파일 타임 의존성은 고정시키고 런타임 의존성을 변경하라.
이를 위해서는 **추상화에 의존**하도록 해야 하고, 이건 결국 OCP의 핵심이기도 하다.
일반적으로 의존하는 대상이 추상적일수록 결합도가 낮아지는 효과를 얻는다. 결합도를 결정하는 건 객체가 서로를 얼마나 알고 있느냐이기 때문이다.

#### 어떻게 추상화를 시키는가

컨텍스트에 따라 변경되는 부분과 변경되지 않는 부분으로 구분하고, 변경되지 않는 부분(핵심)만을 남기면 그게 바로 추상화다.

다음은 추상화 수준으로, 오른쪽에 의존할 수록 더 추상화에 의존한다고 말한다.

* 구체 클래스 < 추상클래스 < 인터페이스

추상클래스는 상속계층에 알아야 한다는 점 때문에 인터페이스보다 덜 추상적으로 본다.

### 의존성 해결하기

의존성을 해결하는 방법에는 3가지가 있다.

* 생성자
* Setter
* 메소드 파라미터

생성을 위한 의존성과 사용을 위한 의존성을 구분해라.
생성을 위한 지식을 사용처에서 알아야 하는가? 몰라도 된다면, 불필요한 결합도를 만들 이유가?
인터페이스 등으로 명시적으로 의존성을 드러내라, 숨겨진 의존성은 나쁘다. 문제가 런타임에 발견되기 때문.

### Pure Fabrication

GRASP 패턴을 따르다 보면 Information expert에게 책임을 할당하는 게 영 어색한 경우가 있는데, 그 때 Pure Fabrication을 사용한다. 대표적인 예시는 바로 Factory.
이는 객체지향이 실세계를 반영한다는 오해가 사실이 아님을 방증한다.
DIP에서 Inversion 이라는 단어가 쓰인 이유는 절차지향과 의존성의 방향이 반대로 되어야지만 유연한 설계를 얻을 수 있기 때문이다.
유연한 설게는 단순함과 명확함을 희생하여 얻는다. 즉, 한마디로 복잡해진다. 따라서 매몰되지 않고 trade off를 현명하게 고려해야 한다.
협력을 재사용해야 하는가? 그렇지 않다면 유연한 설계를 할 필요가 없다.

### 코드의 재사용

코드는 결국 비즈니스의 문제 해결을 위한 공학적 표현이다. 비즈니스는 시간의 흐름에 따라 의사결정에 의해 얼마든지 바뀔 수 있는데,
그 말은 코드 역시 언제든지 변경될 수 있다는 것을 의미한다.
즉, 코드가 중복이라면 이런 변경 때마다 일일이 찾아서 모조리 다 바꾸어야하기 때문에 관리가 힘들어진다.

코드의 재사용방법에는 다음 3가지 방법이 있다.

* 상속
  * 구현상속: 중복 코드를 부모 코드로 올린다(Sub classing).
  * 인터페이스 상속: 부모의 행동을 자식이 보존하는 타입계층을 구현한다(Sub typing).
* 합성: 중복 로직을 담당하는 객체 구현체의 추상화 타입을 프로퍼티에 놓고, 런타임에 해당 객체를 받는다.
* 믹스인: 어떠한 문맥(클래스) 안에서 사용가능한 로직들을 선언하여 컴파일 타임에 코드를 클래스 안에 섞는다. (추상적 서브 클래스)

구현 상속의 경우 하나의 기능을 추가하는 경우에도 여러 클래스를 모조리 수정해야 하는 문제(클래스 폭발 문제)가 발생해서 코드 재사용을 해야 하는 이유에서 제시된 문제를 해결하지 못한다.
따라서 구현상속은 꼭 필요한 경우가 아니라면 피해야 한다.

그럼 언제 상속을 사용하고 언제 합성을 사용해야 할까?

결론부터 이야기 하면, 단순 중복 로직을 재사용하기 위해서라면 합성을 사용하고, 유연한 설계를 위해 타입계층을 구현해야 한다면 상속을 사용해야 한다.
유연한 설계를 위해 타입계층에 대한 이해를 위해서는 다형성에 대해 알아야 한다.

#### 다형성

다형성(Polymorphism)은 하나의 추상 인터페이스에 대해 여러가지 다른 구현을 연결할 수 있는 능력을 말한다. 다음과 같이 분류할 수 있다.

* 유니버셜(Universal)
  * 매개변수(Parametric): Generic을 사용하는 경우
  * 포함(Inclusion): 일반적으로 이야기 하는 다형성은 여기에 해당되는데, 런타임에 전달된 객체에 따라 실제로 수행되는 행동이 달라지는 경우
* 임시(Ad hoc)
  * 오버로딩(Overloading): 한 클래스 안에 같은 이름으로 여러 메소드 존재하는 경우
  * 강제(Coercion): 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

다형성은 절차지향과 대비되는 객체지향의 고유한 특징이다. 절차지향에서는 컴파일 타임에 이미 함수 호출이 결정되어 버리지만,
객체지향에서는 런타임에 어떤 메소드가 호출될 것인지가 결정되는데 이게 바로 유연한 설계를 달성하는 열쇠이다.

이게 가능한 이유는 동적 바인딩과 업캐스팅 때문이다.

##### 동적 바인딩, 업캐스팅

업캐스팅은 부모에 자식의 인스턴스를 할당하는 것이고, 동적 바인딩은 메시지를 수신하는 객체에 따라 실행 메소드를 정하는 방식을 이야기 한다.
객체가 메시지를 수신하게 되면 그 객체를 가리키는 `self` 라는 임시 변수를 만드는데, 해당 변수를 통해 메소드를 탐색하는 과정은 다음과 같다.

* 해당 객체에서 메시지를 처리할 메소드를 찾는다.
* 못찾으면 상속계층의 역방향으로 메시지를 처리할 메소드를 찾는다.
* 그래도 못찾으면 에러를 던진다.

참고로 위 임시 변수는 자바같은 정적 타입언어에서는 `this`, 파이썬같은 동적 타입언어에서는 `self` 라고 이름 지어진다.

위에서 상속계층이라는 말이 나오긴 했지만, 루비의 module, 스칼라의 trait, 스위프트의 protocol, 코틀린의 extension, 자바스크립트의 prototype 등
다른 언어에서 지원되는 문법이 있다면 그러한 부분까지 고려되어서 동적 바인딩이 지원된다. 즉, 꼭 상속이 아니더라도 위 문법들을 통해서도 다형성이 구현될 수 있다는 말이다. 

위 과정에서 못찾으면 상속계층의 역방향에 있는 '다른 객체에게 메시지를 동일하게 전달해서 처리하는 것'을 위임(Delegation)이라고 한다. 
위임의 경우에는 항상 현재의 실행 문맥을 가리키는 `self` 참조를 인자로 전달한다. 마치 클래스의 상속관계를 객체 사이의 합성 관계로 대체하여 다형성을 구현하는 것이다.
`self`를 전달하지 않는 경우는 포워딩(Forwarding)으로 동적 바인딩을 할 수가 없으므로 단순 코드 재사용이 목적이라고 볼 수 있다.

## SOLID

이 모든 내용을 종합해보면 결국은 SOLID라는 5가지 원칙으로 전부 귀결되는 것을 볼 수 있다.

중복이 발생한다는 것은 중복인 부분들을 뗴어내어 합성을 위해 하나의 다른 객체를 만들 수 있다는 것이며, 그 말은 곧 기존 코드가
SRP를 어기고 있었다는 말이 된다.

OCP를 달성하기 위해서는 추상화에 의존하도록 하여 다형성을 구현해야 한다. 다형성을 구현하기 위해서는 위에서 이야기 한 상속(물론 상속 외에 다른 것도 가능하다) 
을 사용해야 하는데, 이 때 자식이 부모를 대체할 수 없거나 부모가 자식을 대체할 수 없다면 업캐스팅이 불가하므로 LSP를 위반할 수 없다.
LSP를 위반하지 않기 위해서는 자신이 사용하지 않는 인터페이스에 의존하면 안되므로 ISP를 준수하여 서브타이핑이 되도록 해야 한다.

마지막으로 추상화에 의존한다는 것은 DIP 역시 위반할 수 없다는 뜻이다. 
