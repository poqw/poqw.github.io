# OOP(Object Oriented Programming)

[![](https://media.vlpt.us/images/ygh7687/post/5a98de44-834d-4980-876a-a736260d0bee/oop.png)](https://velog.io/@ygh7687/OOP%EC%9D%98-5%EC%9B%90%EC%B9%99%EA%B3%BC-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1)

## 객체지향의 오해들

객체지향의 세계에 대해 내가 했었던 오해들을 먼저 풀고 가면 좋을 것 같다. 왜냐하면 이건 내 블로그니까 내 맘이거든. 

### 중복된 코드들을 객체로 묶으면 객체지향이다?

나는 학부시절에 붕어빵과 붕어빵틀이 객체지향의 전부라고 이해했다. 어떤 로직이 중복된다면 그 로직을 클래스(붕어빵틀)로 몰아
인스턴스(붕어빵)를 만들고 메소드를 호출하여 재사용하곤 했다. 객체지향이 별 거 아닌 것만 같은 건방진 생각까지도 들었다.
그러나 프로젝트가 복잡해질수록 엉켜져버리는 의존성때문에 결국 중복을 허용하게 되었고, 얼마 지나지 않아 코드는 악취가 진동해
들여다 보기도 싫은 하수구 취급을 받게 되었다.

객체 지향적으로 프로그래밍을 한다는 말의 의미는, 프로그램이 객체들의 상호 협력에 의해서 운영되도록 한다는 것이다.
딱 한 가지 역할만을 담당하는 객체들이 모여서 자신이 하지 못하는 일들은 다른 객체에게 요청하고 또 다른 객체로부터 받은 요청에 부응하며
하나의 거대한 공동체를 이룬다.

학부 시절의 나 처럼 아무렇게나 막 짠다고 객체가 한 가지 역할만을 잘 담당하도록 자동으로 짜여지진 않는다.
지금와서는 객체는 붕어빵틀보다는, 어쩌면 공동체의 구성원인 사람에게 비유하는 게 더 어울리는 것 같다는 생각을 하고 있다.
우리는 옆 사람에게 내장과 근육조직에 대한 제어권을 넘기라고 하는 대신, 그냥 물을 떠달라고 말한다.
객체도 마찬가지다. **무엇을 하라고 시켜야지 그 속을 드러내보이라고 해선 안된다**, 또 내장이 외부로 흘러나오도록 두어서도 안된다.

객체는 최대한 한 가지 일만을 잘하는 전문가로 만들어 놓아야 한다. 그러려면 외부로 노출되는 인터페이스가 최대한 적어야 한다.
이를 위한 최선의 방법은 메시지를 결정하고, 그 메시지를 처리할 객체를 결정하는 것이다.
클래스를 만들고 그 안에다가 메소드를 만드는 걸로 시작하면 금방 여러가지 일을 하게 되는 혼종 객체가 탄생한다.

### 객체지향은 항상 옳다?

객체는 추상화를 통해 구현을 감추고, 절차지향적인 자료 구조는 있는 그대로를 드러낸다. 구현부를 감추기 위해 인터페이스를 도입하여
여러 객체들이 이 인터페이스를 구현하도록 했다고 하자. 인터페이스에 새로운 기능이 추가되는 경우 모든 객체를 수정해야 하는 난감한 상황에 빠진다.
하지만 이를 거의 구조체와 같은 자료 구조로 만들어 두고, 다른 클래스에서 `instanceof` 로 검사하여 어떠한 기능이 수행되도록 했다면
앞서와 같은 상황에서 모든 자료 구조는 수정으로부터 보호된다. 반면, 새로운 타입이 추가된는 경우에는 객체 지향이 더 좋다.
기존 객체들에 대한 수정을 하지 않아도 되자만, 절차지향에서는 기능을 수행하던 클래스의 모든 메소드가 수정되어야 한다.

따라서 우리는 새로운 자료 타입의 추가가 기대되는 경우 객체 지향으로, 새로운 함수의 추가가 기대되는 경우 절차 지향으로 구현하는 등
항상 객체지향이 올다는 미신은 버려야 한다. 단, 두 가지를 섞게 되면 단점만 모두 가져오는 꼴이므로 섞이지 않도록 주의해야 한다.

## 어떻게 객체지향적으로 프로그래밍 하는가

### 추상화에 의존하라

런타임 의존성(객체)과 컴파일 타임 의존성(클래스)를 구분해서 컴파일 타임 의존성은 고정시키고 런타임 의존성을 변경하라.
이를 위해서는 **추상화에 의존**하도록 해야 하고, 이건 결국 OCP의 핵심이기도 하다.
일반적으로 의존하는 대상이 추상적일수록 결합도가 낮아지는 효과를 얻는다. 결합도를 결정하는 건 객체가 서로를 얼마나 알고 있느냐이기 때문이다.

다음은 추상화 수준으로, 오른쪽에 의존할 수록 더 추상화에 의존한다고 말한다.

* 구체 클래스 < 추상클래스 < 인터페이스

추상클래스는 상속계층에 알아야 한다는 점 때문에 인터페이스보다 덜 추상적으로 본다.

#### 어떻게 추상화를 시키는가

컨텍스트에 따라 변경되는 부분과 변경되지 않는 부분으로 구분하고, 변경되지 않는 부분(핵심)만을 남기면 그게 바로 추상화다.

### 의존성 해결하기

의존성을 해결하는 방법에는 3가지가 있다.

* 생성자
* Setter
* 메소드 파라미터

생성을 위한 의존성과 사용을 위한 의존성을 구분해라.
생성을 위한 지식을 사용처에서 알아야 하는가? 몰라도 된다면, 불필요한 결합도를 만들 이유가?
인터페이스 등으로 명시적으로 의존성을 드러내라, 숨겨진 의존성은 나쁘다. 문제가 런타임에 발견되기 때문.

### Pure Fabrication

GRASP 패턴을 따르다 보면 Information expert에게 책임을 할당하는 게 영 어색한 경우가 있는데, 그 때 Pure Fabrication을 사용한다. 대표적인 예시는 바로 Factory.
이는 객체지향이 실세계를 반영한다는 오해가 사실이 아님을 방증한다.
DIP에서 Inversion 이라는 단어가 쓰인 이유는 절차지향과 의존성의 방향이 반대로 되어야지만 유연한 설계를 얻을 수 있기 때문이다.
유연한 설게는 단순함과 명확함을 희생하여 얻는다. 즉, 한마디로 복잡해진다. 따라서 매몰되지 않고 trade off를 현명하게 고려해야 한다.
협력을 재사용해야 하는가? 그렇지 않다면 유연한 설계를 할 필요가 없다.

### 코드의 재사용

코드는 결국 비즈니스의 문제 해결을 위한 공학적 표현이다. 비즈니스는 시간의 흐름에 따라 의사결정에 의해 얼마든지 바뀔 수 있는데,
그 말은 코드 역시 언제든지 변경될 수 있다는 것을 의미한다.
즉, 코드가 중복이라면 이런 변경 때마다 일일이 찾아서 모조리 다 바꾸어야하기 때문에 관리가 힘들어진다.

코드의 재사용방법에는 다음 3가지 방법이 있다.

* 상속
    * 구현상속: 중복 코드를 부모 코드로 올린다.
    * 인터페이스 상속: 아직 안나옴
* 합성: 중복 로직을 담당하는 객체 구현체의 추상화 타입을 프로퍼티에 놓고, 런타임에 해당 객체를 받는다.
* 믹스인: 어떠한 문맥(클래스) 안에서 사용가능한 로직들을 선언하여 컴파일 타임에 코드를 클래스 안에 섞는다. (추상적 서브 클래스)

구현 상속의 경우 하나의 기능을 추가하는 경우에도 여러 클래스를 모조리 수정해야 하는 문제(클래스 폭발 문제)가 발생해서 코드 재사용을 해야 하는 이유에서 제시된 문제를 해결하지 못한다.
따라서 구현상속은 꼭 필요한 경우가 아니라면 피하는 것이 좋다.
