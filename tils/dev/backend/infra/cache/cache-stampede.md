# Cache stampede

## 개요

캐싱을 적용하고 있는 병렬 컴퓨팅 시스템에서 발생할 수 있는 캐싱 문제이다. 일반적인 캐시는 요청을 받으면 캐시를 검사하여 값이 없다면 연산을 수행하고,
값이 있다면 캐시에 저장된 값을 내려준다. 그러나 다음 시스템을 상상해보자.

* 100 TPS 를 감당해야 함.
* 캐시 만료시간이 3초
* 요청을 받으면 실행해야 하는 연산이 1초 걸림. 

초당 100개의 요청 중 가장 빠른 요청이 수행될 때 캐시가 비어있으므로 연산이 수행되고 1초가 끝나야만 캐시에 값이 업로드가 된다.
그러나 그 말은, 해당 1초 안에 들어온 나머지 99개의 요청 역시 캐시를 조회했으나 값이 없으므로 해당 연산을 똑같이 수행한다는 것이다.

이 99번이나 똑같은 연산을 한는 비효율이 첫번째 문제이다.

또, 캐시가 만료되기 전인 1초~4초 구간 동안은 캐시에 값이 있으므로 연산 수행없이 값을 내려주다가, 4초를 넘어가면서 캐시가 만료되는 순간 캐시가 비어버리므로 똑같은 일이 반복된다.

이것이 2번째 문제이다.

## 문제점 극복

문제점 극복 방식엔 크게 다음 3가지가 있다.

### Locking

첫 번째 요청이 락을 잡고 들어가는 방법이다. 이 때, 락을 잡지 못한 나머지 99개의 요청에 대해서는 크게 3가지 구현 방식이 있다.

* Lock이 풀릴 때까지 기다린다.
* 바로 실패를 던져서 클라이언트가 핸들링하게 만든다(재요청 등).
* 그냥 예전 값을 가져간다.

이걸 하기 위해서는 Lock을 잡는 데 실패하는 경우는 어떻게 처리할 지, TTL 관리를 어떻게 할지, 레이스 컨디션을 어떻게 해결할지에 대한 고민이 필요하다.
이를 통해 위 1번쨰 문제는 해결이 가능하다.

### External recomputation

외부 프로세스에서 연산을 수행하도록 하는 것이다. 여러 가지 방법으로 트리거 하는 방식을 생각해 볼 수 있다. 

* 캐시 만료시.
* 캐시 미스났을 때.
* 그냥 주기적으로.

캐시 만료시 트리거 하는 방식을 좀 더 응용해서, 캐시 만료되기 직전에 (위의 예제의 경우 1초 전에 미리) 비동기 적으로 다른 스레드에서 연산을 수행해서
캐시 만료가 되기 전에 미리 최신화하는 전략을 생각해볼 수 있다. 이를 통해 위 2번째 문재를 극복이 가능하다. 여기다 더해, Lock을 잡는 방법을 결합하여
두 마리 토끼를 다 잡는 방법을 생각해볼 수도 있다. 물론 고려해야 할 것이 엄청 많겠지만...

### Probabilistic early expiration

확률적으로 만료가 되기 전에 캐시를 업데이트 치는 방식이다. 이 확률함수는 캐시가 만료되는 시간에 가까워질수록 재 계산을 수행할 확률이 높아지도록 설계된다.
1, 2번째 문제를 동시에 해결하기 위해 고안되었다. 그러나 확률적으로 캐시 만료나 중복 연산이 발생할 수 있기 때문에 완벽한 해결책은 아니다.
