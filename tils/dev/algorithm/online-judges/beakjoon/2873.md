# 2873 롤러코스터

[문제 링크](https://www.acmicpc.net/problem/2873)

## 문제

상근이는 우리나라에서 가장 유명한 놀이 공원을 운영하고 있다. 이 놀이 공원은 야외에 있고, 다양한 롤러코스터가 많이 있다.

어느 날 벤치에 앉아있던 상근이는 커다란 황금을 발견한 기분이 들었다. 자신의 눈 앞에 보이는 이 부지를 구매해서 롤러코스터를 만든다면, 세상에서 가장 재미있는 롤러코스터를 만들 수 있다고 생각했다.

이 부지는 직사각형 모양이고, 상근이는 R행 C열의 표 모양으로 나누었다. 롤러코스터는 가장 왼쪽 위 칸에서 시작할 것이고, 가장 오른쪽 아래 칸에서 도착할 것이다. 롤러코스터는 현재 있는 칸과 위, 아래, 왼쪽, 오른쪽으로 인접한 칸으로 이동할 수 있다. 각 칸은 한 번 방문할 수 있고, 방문하지 않은 칸이 있어도 된다.

각 칸에는 그 칸을 지나갈 때, 탑승자가 얻을 수 있는 기쁨을 나타낸 숫자가 적혀있다. 롤러코스터를 탄 사람이 얻을 수 있는 기쁨은 지나간 칸의 기쁨의 합이다. 가장 큰 기쁨을 주는 롤러코스터는 어떻게 움직여야 하는지를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 R과 C가 주어진다. (2 ≤ R, C ≤ 1000) 둘째 줄부터 R개 줄에는 각 칸을 지나갈 때 얻을 수 있는 기쁨이 주어진다. 이 값은 1000보다 작은 양의 정수이다.

## 출력

첫째 줄에 가장 가장 큰 기쁨을 주는 롤러코스터는 가장 왼쪽 위 칸부터 가장 오른쪽 아래 칸으로 어떻게 움직이면 되는지를 출력한다. 위는 U, 오른쪽은 R, 왼쪽은 L, 아래는 D로 출력한다. 정답은 여러 가지 일 수도 있다.

## 풀이(Kotlin)

가로나 세로가 홀수인 경우에는 모든 점을 지나야 한다는 것은 그려보면서 깨달았다. 모든 칸이 양수이기 때문이다. 문제는 둘 다 짝수가 되는 경우인데,
최소가 되는 특정 지점을 제외하고 나머지를 모두 밟아야 한다는 생각에서 그림을 그려보았을 때 아무리 생각해도 어느 특정한 한 칸의 경우에는
반드시 다른 칸들도 포기하게 되는 경우가 생겼다. 그래서 그런 경우에는 어떻게 처리해야 하지하고 고민하다가 결국 멘붕에 빠져서 풀이를 살펴보고 말았다.

풀이에서는 체스판을 두고서 해설을 시작한다. 맨 왼쪽 위 칸이 흰색이라면 가로 세로가 짝수 일 때 반드시 도착점은 흰색이다. 그러나, 가로 세로 짝수인 체스판에서
흰 칸과 검은 칸의 수는 항상 일치하므로, 검은 칸 중 최소인 칸을 포기해야 한다고 한다.

풀이를 보고서 든 생각은,

1. 와 이걸 이렇게 수학적으로 생각할 수도 있구나.. 난 이런 생각을 나중에 할 수 있을까?
2. 내가 고민했던 특정한 한 칸은 흰 칸이었구나.
3. 흰 칸과 주변 몇몇 칸을 포기하는 게 더 기쁨을 극대화하는 반례는 없나?

3번 같은 경우는 존재할 수 없다는 건 금방 깨달았다. 흰 칸을 포기하면 그만큼 검은 칸들도 같이 포기해야 하기 때문이다. 흰 칸과 검은 칸의 수는 항상 일치하므로.
풀이를 봐서 슬프긴 하지만 구현은 금방 해내었다. 행과 열 중 어느 것이 가로인 것인지 헷갈리는 바람에 한 번 틀리긴 했지만...

```kotlin
fun main() = with(System.`in`.bufferedReader()) {
  val (r, c) = readLine().split(" ").map { it.toInt() }
  var ans: String
  when {
    r % 2 == 1 -> { // 세로 홀수
      ans = ("R".repeat(c - 1) + "D" + "L".repeat(c - 1) + "D").repeat(r / 2) + "R".repeat(c - 1)
    }
    c % 2 == 1 -> { // 가로 홀수
      ans = ("D".repeat(r - 1) + "R" + "U".repeat(r - 1) + "R").repeat(c / 2) + "D".repeat(r - 1)
    }
    else -> { // 둘 다 짝수
      val arr = Array(r) { IntArray(c) }
      repeat(r) { i ->
        arr[i] = readLine().split(" ").map { it.toInt() }.toIntArray()
      }
      var minX = -1
      var minY = -1
      var min = 1001
      for (i in 0 until r) {
        for (j in 0 until c) {
          if ((i == 0 && j == 0) || (i == c - 1 && j == r - 1)) {
            continue
          }
          if ((i + j) % 2 == 1 && min > arr[i][j]) {
            minY = i
            minX = j
            min = arr[i][j]
          }
        }
      }

      ans = ("D".repeat(r - 1) + "R" + "U".repeat(r - 1) + "R").repeat(minX / 2)
      ans += "RDLD".repeat(minY / 2)
      ans += if (minX % 2 == 0) {
        "RD"
      } else {
        "DR"
      }
      ans += "DLDR".repeat((r - minY - 1) / 2)
      ans += ("R" + "U".repeat(r - 1) + "R" + "D".repeat(r - 1)).repeat((c - minX - 1) / 2)
    }
  }
  print(ans)
}
```

다른 사람의 풀이는 오히려 더 복잡한 듯 했다. 한가지 배웠던 점은 아래 부분을 

```kotlin
      val arr = Array(r) { IntArray(c) }
      repeat(r) { i ->
        arr[i] = readLine().split(" ").map { it.toInt() }.toIntArray()
      }
```

다음과 같이 짧게 나타낼 수도 있다는 점이다.

```kotlin
      val arr = Array(r) { readLine().split(" ").map { it.toInt() } }
```
