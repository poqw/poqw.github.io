# 코틀린 동시성 프로그래밍

## 1장

어플리케이션이 시작되면 OS는 프로세스를 생성하고 메인 스레드를 연결한 뒤 해당 스레드를 실행한다.

프로세스는 어플리케이션의 인스턴스이고, 프로세스 내부의 스레드가 프로세스의 상태(Pid, handle, ...)에 접근이 가능하다.
어플리케이션도 여러 프로세스로 구현될 수 있지만 여기서는 단일 프로세스 구현에 한해서만 다룬다.

프로세스는 최소한 하나의 스레드를 포함하며 보통은 이 스레드는 메인 스레드가 되고, 이 스레드는 프로세스의 라이프 사이클과 밀접하게 연관된다.
각 스레드는 프로세스의 리소스에 접근하는 방법 외에도 각각 로컬 스토리지라는 자체 저장소도 가지고 있다.

### 코루틴

코루틴은 스레드 안에서 실행된다. 스레드 하나에 많은 코루틴이 있을 수 있지만 주어진 시간에 하나의 스레드에서 하나의 명령만이 실행될 수 있다.
즉 같은 스레드에 10개의 코루틴이 있다면 어느 한 시점에는 단 하나의 코루틴만 실행된다. 코틀린은 고정된 크기의 스레드 풀을 사용하고
코루틴들을 스레드들에 배포한다. 따라서 수천 개의 코루틴을 추가하는 것은 거의 영향이 없다. 코루틴이 일시 중단되는 동안 실행 중인 스레드는 다른 코루틴을 실행시키는 데 사용되기 때문이다.

### 동시성과 병렬성

* 동시성은 두 개 이상의 알고리즘의 실행 시간이 겹쳐질 때 발생한다. 코어가 하나라면 여러 스레드에 교차해서 번갈아가면서 실행이 되서 동시에 실행되는 것처럼 보이게 된다. 
* 병렬성은 두 개의 알고리즘이 정확히 같은 시점에 실행될 때 발생한다. 실제로 여러 스레드가 동시에 실행된다.

### CPU 바운드와 I/O 바운드

* CPU 바운드는 CPU 가 처리하는 작업을 중심으로 구현되는 알고리즘에 좌우 되는 성질이다.
* I/O 바운드는 네트워크나 파일 등 입출력에 의존하는 알고리즘에 좌우되는 성질이다.

CPU 바운드에서의 동시적 코드는 단일 코어만 제공되는 경우 기존 순차적 코드보다 오래 걸릴 가능성이 있다. 단지 스레드 교차 배치만 해주는데, 이 과정에서 컨텍스트 스위칭이 일어나는 비용이 들기 때문이다.
병렬 실행의 경우 순차적코드보다 n 배 빨라질 수 있다. 따라서 CPU 바운드라면 현재 사용 중인 장치의 코어 수를 기준으로 적절한 스레드 수를 생성하도록 고려해야 한다.
코틀린의 `CommonPool`은 이러한 CPU바운드 작업에 적절하다.

I/O 바운드에서는 끊임없이 무언가를 기다린다. 따라서 병렬성과 동시성이 유사하게 실행된다. 따라서 항상 동시성 구현으로 실행하는 것이 좋다.

### 동시성 주의사항

주로 다음 문제점들을 겪게 된다.

* 레이스 컨디션: 동시 실행되는 코드를 순차적으로 실행될거라 가정하는 경우에 주로 발생
* 원자성 위반: 데이터 접근 시에 다른 스레드의 간섭이 생기는 경우
* 교착 상태: 두 스레드가 서로를 기다리고 있는 경우
* 라이브 락: 교착 상태와 비슷, 다만 차이점은 상태는 계속 변하지만 이 변한 상태가 또 다시 다른 스레드를 막는 경우. 보통 교착 상태를 복구하려고 만든 알고리즘에서 많이 발생한다.

### 코틀린에서의 동시성

#### 넌 블로킹

코틀린은 중단 가능한 연산기능을 제공한다. 스레드를 블로킹 하는 대신 대기해야 하는 코드를 일시 중단하고 그 동안 해당 스레드를 다른 연산 작업에 사용한다. 이를 위해 Channels, Actors, Mutaual exclusions 와 같은 인터페이스 및 자료형을 제공한다.

#### 명시적인 선언

I/O 바운드는 동시성으로 묶는다는 관점에서 아래코드는

```kotlin
fun main () = runBlocking {
	val name = getName()
	val lastName = getLastName()
	println("$name $lastName")
}

suspend fun getName(): String {
  delay(1000)
  return "hyungsun"
}

suspend fun getLastName(): String {
  delay(1000)
	return "song"
}
```

다음과 같이 묶는게 좋다.

```kotlin
fun main () = runBlocking {
	val name = async { getName() }
	val lastName = async { getLastName() }
	println("${name.await()} ${lastName.await()}")
}
```

이런 식으로 동시에 실행되야 하는 시점을 명시적으로 코드에 표현할 수 있다.

이 외에도 여러 장점들이 있는데,

- 가독성: async - await 페어로 쓰일때 관용구로 보통 함수 이름을 async로 시작하거나 끝맺도록 하여 가독성을 높일 수 있다.
- 기본형 활용: 스레드를 관리하는 코드를 기본형을 제공한다.
- 유연성
    - Channels: 코루틴 간에 데이터 전송해주는 파이프
    - Worker pools: 많은 스레드에서 연산 집합의 처리를 나눌 수 있는 코루틴 풀
    - Actors: 채널과 코루틴을 사용하는 상태를 감싼 래퍼
    - Mutex: 동기화 메커니즘 제공
    - Thread confinement: 코루틴의 실행을 제한해서 지정된 스레드에서만 실행되도록 하는 기능
    - 생성자: 필요에 따라 정보를 생성할 수 있고, 새로운 정보가 필요하지 않을 때 일시 중단될 수 있는 데이터 소스

### 용어

- Suspending Computation: 해당 스레드를 차단하지 않고 실행을 일시 중지할 수 있는 연산. 이 연산은 다른 Suspending computation 이나 suspending function 에서만 실행되는 특징을 가진다.
- Suspending Function: Suspending Computation의 함수 형태. 위 `getName()` 이 예시이다.
- 람다 일시 중단: 람다에 suspend 가 붙은 형태
- 코루틴 디스패처: 코루틴을 시작하거나 재개할 스레드를 결정하기 위해 코루틴 디스패처가 사용된다. 모든 코루틴 디스패처는 CoroutineDispatcher 인터페이스를 구현해야 한다.
- 코루틴 빌더: suspend lambda를 받아 실행시키는 코루틴을 생성하는 함수다.
    - async: Deffered<T> 를 반환한다.
    - launch: Job 을 반환한다.
    - runBlocking: 내부 코루틴 실행 끝날 때까지 현재 스레드 차단.

